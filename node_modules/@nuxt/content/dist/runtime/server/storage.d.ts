import type { CompatibilityEvent } from 'h3';
import type { QueryBuilderParams, ParsedContent, QueryBuilder, ContentTransformer } from '../types';
import type { ModuleOptions } from '../../module';
interface ParseContentOptions {
    csv?: ModuleOptions['csv'];
    yaml?: ModuleOptions['yaml'];
    highlight?: ModuleOptions['highlight'];
    markdown?: ModuleOptions['markdown'];
    transformers?: ContentTransformer[];
    pathMeta?: {
        locales?: ModuleOptions['locales'];
        defaultLocale?: ModuleOptions['defaultLocale'];
    };
    [key: string]: any;
}
export declare const sourceStorage: import("unstorage/dist/types-ba4f7911").S;
export declare const cacheStorage: import("unstorage/dist/types-ba4f7911").S;
export declare const cacheParsedStorage: import("unstorage/dist/types-ba4f7911").S;
/**
 * Content ignore patterns
 */
export declare const contentIgnores: Array<RegExp>;
export declare const getContentsIds: (event: CompatibilityEvent, prefix?: string) => Promise<any[]>;
export declare const getContentsList: (event: CompatibilityEvent, prefix?: string) => Promise<ParsedContent[]>;
export declare const getContent: (event: CompatibilityEvent, id: string) => Promise<ParsedContent>;
/**
 * Parse content file using registered plugins
 */
export declare function parseContent(id: string, content: string, opts?: ParseContentOptions): Promise<{
    _id: any;
    body: any;
}>;
export declare const createServerQueryFetch: <T = ParsedContent>(event: CompatibilityEvent, path?: string) => (query: QueryBuilder<T>) => Promise<T | T[]>;
/**
 * Query contents
 */
export declare function serverQueryContent<T = ParsedContent>(event: CompatibilityEvent): QueryBuilder<T>;
export declare function serverQueryContent<T = ParsedContent>(event: CompatibilityEvent, params?: QueryBuilderParams): QueryBuilder<T>;
export declare function serverQueryContent<T = ParsedContent>(event: CompatibilityEvent, path?: string, ...pathParts: string[]): QueryBuilder<T>;
export {};
